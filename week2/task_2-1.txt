Изменить программу из задания 1.4 таким образом, чтоб из произвольного текста можно было извлекать произвольные объекты (а не только класса Person). Т.е. кроме класса Person может быть любой другой класс или классы, для которых соблюдаются общие принципы: объекты имеют какие-то текстовые поля и возможность определнным образом представить объект в виде строки. Какие это поля и как представлять объект в виде строки - заранее неизвестно, и должна быть возможность легко добавлять новые классы, которые будут использоваться парсером.

В конечном счете программа должна уметь принять на вход текст и набор делегатов, каждый из которых умеет парсить свой тип объекта. Затем программа пробегает по тексту и обрабатывает его делегатами, на выходе производит коллекцию всех найденных объектов. Всех - это важно! На выходе одна коллекция, независимо от того, сколько типов объектов ищет парсер! Для этой коллекции должна быть возможность удалить дубликаты (написать для этого extension method).

Обязательно предусмотреть возможность исключений и обеспечить их обработку!

 

Примеры сущностей

// Example: “John Smith (1983/11/05, male)”

class Person {…}


// Example: “FC Dynamo (Kyiv, Ukraine, est. 1927)”

class FootballClub {…}

// Example: “Microsoft (Information Technology, US)

// Example: “Volkswagen Group (Automotive, DE)

// Example: “Auchan (Retail, FR)

class Company {…}

Важно: парсер нужно сделать так, чтоб можно было легко добавить новые типы сущностей и не пришлось переписывать сам парсер. Т.е. для это надо как-то задавать правила парсинга каждой сущности, но чтоб парсер при этом работал универсально. Как вариант, такое удобно реализовать регулярными выражениями. Например, на вход парсеру подается текст и набор пар (регулярное выражение, сущность), или лямбда-выражения для каждого типа сущности или еще как-то иначе. Парсер последовательно применяет каждое рег.выражение/правило/лямбду к тексту и находит соотв. сущности. Таким образом, когда появятся новые сущности, достаточно будет лишь добавить новые правила на вход парсеру. Как вариант, для большего удобства можно эти регулярные выражение задавать как статические поля в самих сущностях, и тогда на вход парсеру передавать набор статических полей сущностей, а не сами регулярные выражения.

Пример входных данных - новости, текст одним куском

“Last year winner FC Dynamo (Kyiv, Ukraine, et. 1927) lost the game with 0:2 to FC Kryvbas (Kryvyi Rih, Ukraine, est. 1959).

Share price of Microsoft (Information Technology, US) dropped to $100

John Smith (1983/11/05, male) has been sentenced to a 3 year imprisonment for corruption”

На выходе нужно получить одну коллекцию из сущностей, найденных в тексте новостей.

Подсказка: разумеется, что коллекция должна иметь определенный тип. Для того, чтоб в эту коллекцию впихнуть объекты разных типов, необходимо все их свести к одному типу. Это будет либо Object, либо какой-то другой, если вы решите все сущности унаследовать от некоего класса или интерфейса.

Т.е. на выходе в зависимости от вашего решения может быть List<object>, List<IEntity>, List<Entity>, IEnumerable<object>, IEnumerable<IEntity>, IEnumerable<Entity> (IEntity и Entity - это примеры базовых классов/интерфейсов, у вас могут быть свои, смотря как реализуете)

По коллекции можно пройти и вывести на экран сущности.

При этом в новостях одна и та же сущность может встретиться несколько раз, поэтому из коллекции нужно удалять дубликаты.

Примечание: не нужно спешить и делать что попало. Внимательно и аккуратно подойдите к решению задачи. Предварительно изучите теорию. Подсказка: основная идея в применении интерфейсов, лямбда-выражений, виртуальных методов, интерфейса IComparable. Но это лишь варианты, единственного верного решения здесь нет. Важно сделать удобную, надежную, гибкую программу. Пишите и задавайте вопросы по ходу!